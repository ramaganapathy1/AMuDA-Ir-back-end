architectural considerations for distributed rfid tracking and monitoring zhao cao yanlei diao prashant shenoy dept  of computer science university of massachusetts amherst  ma 01003  usa dept  of computer science university of massachusetts amherst  ma 01003  usa dept  of computer science university of massachusetts amherst  ma 01003  usa caozhao @ cs.umass.edu yanlei @ cs.umass.edu abstract in this paper we discuss architectural challenges in designing a distributed  scalable system for rfid tracking and monitoring  we argue for the need to combine inference and query processing techniques into a single system and consider several architectural choices for building such a system  key research challenges in designing our system include   i  the design of inference techniques that span multiple sites   ii  distributed maintenance of inference and query state   iii  sharing of inference and query state for scalability  and  iv  the use of writeable rfid tags to transfer state information as objects move through the supply chain  we also present the status of our ongoing research and preliminary results from an early implementation  1 introduction rfid is a promising electronic identification technology that enables a real-time information infrastructure to provide timely  high-value content to monitoring and tracking applications  an rfid-enabled information infrastructure is likely to revolutionize areas such as supply chain management  health-care and pharmaceuticals  consider  for example  a distributed supply chain environment with multiple warehouses and millions of tagged objects that move through this supply chain  each warehouse is equipped with rfid readers that scan objects and their associated cases and pallets upon arrival and departure and while they are processed in the warehouse  in order to track objects and monitor the supply chain for anomalies  several types of queries may be posed on the rfid streams generated at the warehouses  tracking queries  report any pallet that has deviated from its intended path  list the path taken by an item through the supply chain  containment queries  raise an alert if a flammable item is not packed in a fireproof case  verify that food containing peanuts is never exposed to other food cases for more than an hour  hybrid queries  report if a drug has been exposed to a temperature of more than 80 degrees for 12 hours  the first class of queries are location queries that require object locations or location history  the second class involves containment  i.e  relationships between objects  cases and pallets  the third kind involves processing of sensor streams  e.g  temperature readings  in conjunction with rfid streams to detect certain conditions  typically raw rfid streams contain noisy data that lacks any location or containment information  hence  such continuous queries require derivation of location and containment information from raw rfid data as well as processing of heterogeneous sensor streams along with rfid data streams  in this paper  we discuss the architectural challenges in designing a scalable  distributed stream processing system for rfid tracking and monitoring  we propose to combine location and containment inference with scalable query processing into a single architecture  in contrast to prior approaches that dealt with these two problems separately  we present three architectural choices in instantiating such a system over large supply chains and present an analysis of their communication overheads  by doing so  we show that the choice between centralized and distributed approaches mainly depends on the read frequency of rfid readers and the number of active queries in the system  furthermore  utilizing local storage of writeable rfid tags for inference and query processing makes the distributed approach a better solution with significantly reduced communication cost  in this paper  we also describe key technical challenges in designing a distributed architecture  which include  i  the design of novel inference techniques that span multiple warehouses of the supply chain   ii  distributed  consistent maintenance of inference and query state as objects move through the supply chain  and  iii  sharing of inference and query state for scalability  a novel aspect of our system is its ability to exploit writeable rfid tags  when available  and use the onboard tag storage to transfer query and inference state as the object moves from one location to another  we finally present the status of our ongoing research and preliminary results from an early implementation  2 permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page  to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee  netdb 09 big sky  mt usa copyright 200x acm x-xxxxx-xx-x/xx/xx  $ 10.00  shenoy @ cs.umass.edu related work rfid stream processing  the hifi system  9  12  offers a declarative framework for rfid data cleaning and processing  it focuses on per-tag smoothing and multi-tag aggregation  but does not capture relationships between objects such as containment or estimate object locations via containment  our system can produce a rich event stream with object location and containment information  it further offers distributed inference and event processing methods  central server local server local server warehouse warehouse local server warehouse local server warehouse objects  tags  figure 1  a distributed rfid data management system  rfid databases  siemens rfid middleware  20  uses application rules to archive rfid data streams into databases  cascadia  21  supports rfid-based pervasive computing with event specification  extraction and archival  techniques are also available to integrate data cleansing with query processing  16   encode flow information  13  and recover highlevel information from incomplete  noisy data by exploiting known constraints  23   these techniques  however  are not designed for fast rfid stream processing and only for centralized processing  event query processing  most event processing methods  1  14  22  use centralized processing which requires all rfid data to be transferred to a single site  incurring high communication cost  the system in  2  uses multi-step event acquisition and processing to minimize event transmission cost  in contrast  our system performs both inference and query processing  does so at a local site whenever possible  and then transmits computation state across sites for distributed inference and event pattern detection  probabilistic inference in sensor networks  there have been several recent techniques  15  5  18  11  for inferring the true value of a phenomenon  such as temperature  light  or an objects position  that a sensor network is deployed to measure  our inference problem differs because we aim to infer inter-object relationships  such as containment  that sensors can not directly measure  hence the different design of our graph model for inference  further  our system combines inference with query processing into a single architecture and explores advanced techniques to reduce the combined cost of inference/query state migration in a distributed system  3 overview of the spire system in this section  we provide an architectural overview of a distributed rfid data management system  which we call spire  this system is designed to support rfid-based tracking and monitoring in large-scale supply chains with multiple warehouses and millions of objects  in a typical environment as depicted in figure 1  each object is affixed with a tag that has a unique identity under the epc standard  7   most tags are passive tags that have no individual power systems but small amounts of memory  e.g  1-4 kb in the current generation of epc tags  17  and up to 64kb  10  in the next generation  such tag memory can be used to store object information and facilitate query processing as we describe in the next section  an rfid reader periodically sends a radio signal to the tags in its read range ; the tags use the radio energy to send back their tag ids  the reader immediately returns the sensed data in the form of  tag_id  reader_id  time   the local servers of a warehouse collect raw rfid data streams from all of the readers  and filter  aggregate  and process these streams  the data streams from different warehouses are further aggregated to support global tracking and monitoring  we next illustrate two tracking and monitoring queries using an extension of the continuous query language  3  with additional constructs for event pattern matching  1  22   these queries assume that events in the input stream contain attributes  tag_id  time  location  container  and optional attributes describing object properties  such as the type of food and expiration date  which can be obtained from the manufacturers database1  it is worth noting the difference in schema between raw rfid readings and events required for query processing  such differences motivate our work on inference  which is discussed shortly  query 1 below is an example of containment queries  it sends an alert when peanut-free food has been contained in the same case as food containing peanuts for more than 1 hour  the inner  nested  query block performs a self-join over the input stream  where one join input retains only the events for peanut-free food  the other input retains only those for food containing peanuts  and the join is based on equality on container  each join result represents an event that a container contains both food with peanuts and foot without peanuts  this event is published immediately into a new stream  the outer query block detects a sequence pattern over the new stream  each match of the pattern contains a sequence of events that refer to the same tag id of the peanut free-food and span a time period of more than 1 hour  for each pattern match  the query returns the tag id of the peanut free food and the length of the periodsuch information can assist a retail store in deciding whether to dispose of the food  query 1  select tag_id  a  a.len  .time  a  1  .time from  select rstream  r1.tag_id  r1.loc  from food  range 3 minutes  as r1  food  range 3 minutes  as r2 where r1.type = peanut free and r2.type = peanut and r1.container = r2.container  as s  pattern seq  a+  where a  i  .tag_id = a  1  .tag_id and a  a.len  .time > a  1  .time + 1 hr  query 2 combines rfid readings with temperature sensor readings and alerts if an object has been exposed to a temperature of more than 80 for 12 hours  it has a similar structure as query 1  but returns all the sensor readings in the period when the temperature regulation was violated  query 2  select tag_id  a   .temp from  select rstream  r.tag_id  r.loc  t.temp  from object  now  as r  temperature  rows 1 minute  as t where r.type = drug and t.temp > 80 and r.loc ' t.loc  as s  pattern seq  a+  where a  i  .tag_id = a  1  .tag_id and a  a.len  .time > a  1  .time + 12 hrs  the spire system we design has two main functionalities  inference and query processing  both of them can be 1 how to obtain the object properties to the site of query processing is an architectural issue  which we discuss in the next section   c  query processing query 1 distributed processing w state migration on  query m query 2 o2 o2 o1 query state distributed a  1  a  i  distributed f   local processing window window event stream local < tag_id  time  location  container   > inference state  b  inference  location and containment local & distributed inference with state migration local 2 1 7 3 5 4 8 9 6 10 11 12 raw rfid stream < tag_id  reader_id  time >  a  rfid sensing  figure 2  architectural overview of the spire system  implemented in a centralized or distributed fashion  the tradeoffs between these implementation choices are the focus of the next section  inference  while data stream processing has been a topic of intensive recent research  rfid data stream processing presents several new challenges  i insufficient information  as the above examples show  query processing often requires information about object locations and inter-object relationships such as containment  however  raw rfid data contains only the observed tag id and its reader id due to the limitations of being an identification technology  i incomplete  noisy data  the problem of deriving location and containment information from raw data is compounded by the fact that rfid readings are inherently noisy  with read rates in actual deployments often in the 60 % -70 % range  12   this is largely due to the sensitivity of radio frequencies to environmental factors such as occluding metal objects and interference  8   mobile rfid readers may read objects from arbitrary angles and distances  hence more susceptible to variable read rates  in spire  we design an inference module that derives object locations and containment relationships despite missed readings  this module resides between the rfid sensing module and the query processing module  as shown in figure 2 we focus on containment in the following discussion  inference for object locations alone is detailed in our recent publication  19    first  an rfid reader can read several containers and all of their contained items simultaneously  which makes it difficult to infer the exact container of each item  in spire  we explore the correlations of observations obtained at different locations at different times to infer containment  for instance  while the containment information at the loading dock of a warehouse is ambiguous due to the readings of two containers simultaneously  true containment may be revealed at the receiving belt where containers are read one at a time  such containment remains unchanged as containers are placed on shelves but may change later in the repackaging area  the inference algorithm needs to adapt to such changes in a timely fashion  however  missed readings significantly complicate the inference problem  consider a scenario that an item was last seen in location a with its container  now its container is observed in b but the item is not observed in any location  there are a few possible locations for the item  it was left behind in location a but the reading in a was missed ; it moved to location b with its container and its reading in b was missed ; it disappeared unexpectedly  e.g  stolen   the inference algorithm needs to account for all these possibilities when deriving containment and location information  in spire  we employ a time-varying graph model to infer object location and containment information  as depicted in figure 3  the example is taken from our icde poster paper  6    our graph model g =  v  e  encodes the current view of the objects in the physical world  including their reported locations and  unreported  possible containment relationships  in addition  the model incorporates statistical history about co-occurrences of objects  the node set v of the graph denotes all rfid-tagged objects in the physical world  these nodes are arranged into layers  with one layer for each packaging level  e.g  an item  case or a pallet  which is encoded in each tag id  nodes are assigned colors to denote their locations  the node colors are updated from the rfid readings in each epoch using the color of the location where each tag is observed  if an object is not read in an epoch  its node becomes uncolored but retains memory of the most recent observation  the directed edge set e encodes possible containment relationships between objects  we allow multiple outgoing and incoming edges to and from each node  indicating an object such as a case may contain multiple items  and conversely  an item may have multiple potential cases  our probabilistic inference will subsequently chose only one of these possibilities   to enable inference  the graph also encodes additional statistics  each edge maintains a bit vector to record recent positive and negative evidence for the co-location of the two objects  for example  the recent co-location bit vector for nodes 3 and 7 in figure 3 is 01 at time t=2 and and 011 at t=3  further  each node remembers the last confirmed containment by a special reader such as a belt reader that scans cases one at a time  for example  at time t=2 in the figure  the belt reader confirms that the edge from node 3 to node 7 represents the true containment  this information stays valid for a while but then becomes obsolete when containment changes  in summary  the graph model encodes the following information about each object for inference  which we call the inference state   i  the most recent observation of the object   ii  all of its possible containers   iii  its recent colocation history with each of the containers  and  iv  its confirmed container in the past by a special reader  after the graph is updated from the rfid readings in each epoch  an inference algorithm runs on the graph to estimate the most likely container and location of each object  our algorithm combines node inference  which derives the most likely location of an object  with edge inference  which derives the most likely container of an object  in an iterative fashion through the graph  in particular  the algorithm t=1 time level 1 level 2 level 3 t=2 1  a,1   a,1   a,1  2  a,1  3 5 4 6  a,1   a,1   a,1  a  loading dock locations t=3 1  a,1  2  b  2  3 8  c,3  1  a,1   c,2  9  a,1  2  c,3  3  c,3  9 5 4 6 7 10 11 4 5 6 11 7 10  a,1   a,1   b,2   b,2   c,2   c,2   a,1   a,1   b,3   c,3   c,2   c,3  c  packaging area b  belt c  packaging area b  belt figure 3  examples of the time-varying colored graph model for containment and location inference  runs  1  from the colored nodes  with known locations    2  through the edges linked to the colored nodes  where edge inference determines the container of a color node   3  to the uncolored nodes incident to these edges  where node inference determines the location of an uncolored node given its recent color and the colors of the processed neighboring nodes   4  to the edges linked to these nodes  and so on  as such  inference sweeps through the graph in increasing distance from the colored nodes  the above description assumes that all the data is available at a central server for inference  if inference is to be made in a distributed fashion  as objects move from site to site we need to transfer inference state with the objects so that information is available for subsequent inferencethis process is called inference state migration  revisit the example in figure 3 suppose that after time t=3  cases 2  3 and items 4  5  7 move to a new warehouse and are observed at the loading dock of the new warehouse  now we want to infer the containers of items 4  5  7 the information in the previous inference state  such as case 3 being the confirmed container of item 7 and the co-location history of items 4  5 with case 2  3  will be very useful to the inference in the new location  this indicates that inference state needs to be maintained across sites on a global scale  we detail several architectural choices for doing so in the next section  query processing  as the inference module streams out events with inferred location and containment information  the query processor  as shown in figure 2  c   processes these events to answer continuous monitoring queries like the two examples above  as the figure shows  part of query processing can be performed at each warehouse  such as filtering of events based on object properties  queries 1 and 2   a selfjoin over the input stream  query 1   and a join between an object stream and a sensor stream  query 2   a more challenging issue is with the part of query processing that spans sites  such as the detection of a complex pattern over a large period of time  see the pattern clause in queries 1 and 2   our discussion first assumes that queries run at a central server with all the information needed for query processing transfered to the server  our query processing module employs a new type of automaton to govern the pattern matching process  each query automaton comprises a nondeterministic finite automaton and a match buffer that stores each match of the pattern  the automaton for query 1 is depicted in figure 2  c   the start state  a  1   is where the kleene plus operator starts to select the first relevant event into the match buffer  at the next state a  i   it attempts to select zero  one  or more events into the buffer  the final state  f  represents the completion of the matching process  each state is associated with a number of edges  representing the possible actions  each edge has a formula expressing the condition on taking the edge  edge formulas are evaluated using the values from the current event as well as the previous events   details of this query automaton model are reported in our recent publication  1    in summary  the following information  called the query state  is maintained to evaluate a pattern query using our automaton model   i  the current automaton state   ii  the minimum set of values extracted from the input events that future automaton evaluation requires  e.g  a  1  .tag id and a  1  .time for query 1  details on extracting these values are available in  1    and  iii  the set of values that the query intends to return  which can be simple values as in query 1  or a long sequence of readings as in query 2 if the pattern query is defined on a per-object basis  as in both of our example queries  the system needs to maintain a copy of query state for each object  as depicted by the copies labeled o1   on in figure 2  c   finally  if a monitoring system supports multiple queries  the size of query state is further multiplied by the number of concurrent queries  similar to inference  if we evaluate pattern queries in a distributed fashion  we need to perform query state migration across sites so that we can resume the automaton execution in a new location and continue to expand the set of values that the query intends to return  4 architectural choices  benefits and drawbacks there are three possible choices for instantiating the system architecture presented in the previous section  centralized warehouse  this simplest approach is to employ a centralized architecturesimilar to a centralized warehousewhere all rfid data is sent to a central location for stream processing  and possibly archival  the advantage of such a centralized approach is that the system has a global view of the entire supply chain  which simplifies stream processing  inference is also simpler since all of the object state is maintained at a single location  in this case  the local servers depicted in figure 1 only need to perform simple processing tasks such as cleaning and/or compression  the primary disadvantage of the approach is the high communication cost of transmitting rfid streams to the central location ; since rfid data can be voluminous  the network bandwidth costs can be substantial  analysis  consider a supply chain with 1000 warehouses  where each warehouse stores 10,000 cases  and each case contains 10 items  both the number of readers in a warehouse and the read frequency of each reader will vary in different supply chains  more readers and a higher read frequency yield greater monitoring accuracy  but can also lead to higher deployment and data processing costs  the choice of these parameters depends on the system budget and the monitoring requirement  assume that  on average  there are between 500 to 5000 rfid readings per object every day depending on the actual deployment  further  assume that the temperature sensors report temperature readings every 5 minutes and that there are 100 temperature sensors in each warehouse  let each rfid reading tuple be 20 bytes  and temperature reading tuple be 9 bytes  a simple calculation shows that  in this scenario  approximately 1.1 to 11 tb of data will be sent to the central location every day  even if a compression scheme offers a factor of 20 reduction in data volume  a figure that we have observed in our recent research  this will still yield between 55 gb to 550 gb of data each day  however  such compression requires that location inference be done locally before transferring location tuples to the central server   details of the above analysis and other analysis in the rest of the section are available in our technical report  4    distributed processing with state migration  an alternative to the centralized approach is to employ distributed stream processing  in this approach  each warehouse employs local stream processingcontinuous queries on objects that reside in the warehouse are processed locally  as objects move through the supply chain from one warehouse to another  queries on those objects also move from one warehouse site to another in order to ensure local processing  the advantage of such an approach is that communication costs are significantly lowered since local processing implies that rfid streams are processed on-site  however  the approach is not without drawbacks  first  the approach requires state migration to transfer the inference state and query state associated with an object whenever it moves from one warehouse to another  such state overhead is high whenever historical information is involved  for either inference or query processing   second  inference techniques become more complex  the inference state must be distributed across multiple sites while presenting the same logically unified view of the global state of the system as the centralized approach  the design of such distributed inference techniques is still an open research question and a focus of our work  finally  since the distributed approach has no global view of the supply chain  queries that involve objects residing in different warehouse locations are more complex  for instance  queries might be tracking different parts required to assemble a product to ensure that they arrive at a factory within a short time of one another ; since each part can take a different path through the supply chain  local query processing is either infeasible or may require substantial state exchange between different warehouse sites and the central location  analysis  assuming the same scenario as before  based on the time-varying graph model in section 3  if 10 cases are read by the exit reader of the warehouse each time  the number of possible containers for each item is approximated by 10 in this analysis  it varies in practice with the co-location history and actual read rates of readers   then the inference state of each object can be  roughly  estimated to be 184 bytes  hence  the size of the inference state migrated every day across all warehouses is round 18.4 gb  as for query processing  object properties such as type of food are required for processing and need to be fetched from the manufacturers database to each warehouse  assuming 100 bytes for each object  the total cost of fetching object properties is 11 gb every day  we estimate the size of query state using techniques in  1   e.g  17 and 37 bytes  including a 12 byte tag id  per object for query 1 and query 2  respectively  if there are 10 queries of type query 1 and 10 queries of type query 2  the query state migrated every day is 54gb  then the total communication cost is 83.4 gb every day  and the ratio of communication cost between the centralized and distributed approach varies from 0.65 to 6.7  depending on the rfid read frequency  thus  there is a cross-over point between these two approachesif an object is read more than 750 times a day  the distributed approach has better performance ; otherwise  the centralized approach is better  another important observation is that the ratio of communication cost between centralized and distributed approaches is independent of the size of the supply chain  the number of warehouses and number of objects in each warehouse   it only depends on  1  the rfid read frequency for each object  as discussed above  and  2  the number of queries in the system  to understand the effect of the latter  consider a setting where there there are 100 queries of type query 1 and 100 queries of type query 2 in this setting  the query state migrated every day is 540 gb  then the total communication cost of the distributed approach is 569.4 gb every day  even larger than the centralized approach  on the other hand  if the system has fewer queries and higher read frequency  the distributed approach is a better choice  distributed processing with local tag storage  our final architecture is an optimization of the distributed architecture where writeable rfid tags with onboard memory are exploited for further reducing the communication overheads  in this case  the state of all queries associated with an object as well as inference state is written onto the tag memory prior to departure from a warehouse  upon arrival at a new warehouse  the tag memory is read and is used to seed the queries and the inference graph at the new location  it is important to note that the tag memory is used as a cache and that query/inference state continues to be stored at the prior location as before in the event the tag memory can not be read for any reason  the approach reverts to state migration  where this state is fetched from the previous warehouse as before  thus  writeable tags can be exploited to optimize overheads and the system correctness is not impacted even when tag memory is not available  or becomes corrupt   analysis  since each tag already carries its id  the 12-byte tag id can be saved from any of the state regarding the object when stored in the tags memory  for each object  the size of object properties then becomes 88 bytes  the inference state becomes 172 bytes  and with the same number of queries  the size of query state becomes 300 bytes  all the object properties and inference/query state that need to be stored on each tag total 560 bytes  in this approach  the amount of data that needs to be stored is independent of the size of supply chain and the reader settings  the only factor that impacts the storage size is the number of queries  to illustrate  if there are 100 queries of each type  the size of query state becomes 3000 bytes  then the object properties and inference/query state that needs to be stored on each tag totols 3.2 kb  the above analysis shows that query state dominates the storage cost  larger numbers of queries may challenge the scalability of this approach  advanced techniques that share query state to save storage are outlined in the next section  5 status and ongoing work 60 error rate  %  objects can share a single copy of the state in their aggregate memory  hence reducing the amortized memory usage in each tag  these schemes can also be used to reduce communication cost during state migration  acknowledgements  this work has been supported in part by the national science foundation under the grants iis-0746939  iis-0812347  and cns-0626873  containment inference error location inference error 50 40 30 20 10 6  0 0.5 0.6 0.7 0.8 0.9 1 read rate figure 4  results of location and containment inference  as of august 2009  we have implemented the inference module and the query processor in a centralized fashion as well as a simulator for enterprise supply chains  our inference module includes a time-varying graph model that captures recent observations of objects and possible object containment relationships  and an online probabilistic algorithm that estimates the most-likely container and location of each object as new data arrives  using rfid streams emulating a large warehouse  our results as shown in figure 4 indicate that location inference can achieve 90 % accuracy even for low read rates such as 50 %  our containment inference can achieve 90 % accuracy when the read rates reach 85 %  it has reduced accuracy for lower read rates due to both the loss of containment confirmation from special readers like belt readers and lack of consistent observations in the recent history  we are currently investigating advanced machine learning techniques to improve inference accuracy for the range of low read rates  our initial results also show the inference techniques to be efficient  they can scale to 100,000 objects while running at stream speed  our ongoing work further explores a host of research issues for distributed inference and event query processing  migrating inference state  when a set of of objects leave a warehouse  we need to split the graph constructed for inference  and transfer a subgraph relevant to these objects to the next warehouse  state migration  or store a subgraph relevant to each object in its tag memory  using local storage   these objects may be connected to other objects in the graph due to ambiguous containment  and only some of them may be sensed by the exit reader  hence  it is a nontrivial issue to identify a subgraph that is large enough for accurate inference later but does not include unnecessary data  to further save bandwidth or storage  we also consider methods to truncate the historical information included in the graph without affecting accuracy  sharing query and inference state  to support multiple queries over millions of objects  we need to maintain a copy of query state per query per object  consider the approach that stores query state in local tag memory  the tag memory then needs to hold the state of all the queries relevant to this object  this requires intelligent packing schemes given limited tag memory  one of our schemes exploits multiquery optimization  for all queries relevant to an object  we construct a shared query plan  e.g  a combined automaton  and further merge their query states once they become equivalent  as such  we can store merged query state using less tag memory  another scheme exploits stable containment  all the objects that have been contained in the same container are likely to have the same state for each active query as well as the same inference state  therefore  all the references  1  j agrawal  y diao  d gyllstrom  et al  efficient pattern matching over event streams  in sigmod  147160  2008   2  m akdere  u cetintemel  and n tatbul  plan-based complex event detection across distributed sources  pvldb  1  1  :6677  2008   3  a arasu  s babu  and j widom  cql  a language for continuous queries over streams and relations  in dbpl  119  2003   4  z cao  y diao  p shenoy  architectural considerations for distributed rfid tracking and monitoring  http  //www.cs.umass.edu/~yanlei/spire.pdf  umass tech  report  2009   5  m cetin  l chen  et al  distributed fusion in sensor networks  in ieee signal processing mag  4255,2006   6  r cocci  t tran  y diao  and p shenoy  efficient data interpretation and compression over rfid streams  in icde  2008 poster   7  epcglobal inc epcglobal tag data standards version 1.3 http  //www.epcglobalinc.org/  mar 2006   8  k finkenzeller  rfid handbook  radio frequency identification fundamentals and applications  john wiley and sons  1999   9  m j franklin  s r jeffery  et al  design considerations for high fan-in systems  the hifi approach  in cidr  290304  2005   10  fujitsu  http  //www.fujitsu.com/global/news/pr/ archives/month/2008/20080109-01.html   11  a ihler  j fisher and et.al  nonparametric belief propagation for self-calibration in sensor networks  in ipsn  225233,2004   12  s r jeffery  m j franklin  et al  an adaptive rfid middleware for supporting metaphysical data independence  vldb journal  17  2  :265 289  2007   13  c.-h lee and c.-w chung  efficient storage scheme and query processing for supply chain management using rfid  in sigmod  291302  2008   14  y mei and s madden  zstream  a cost-based query processor for adaptively detecting composite events  in sigmod  2009   15  m paskin  c guestrin and j mcfadden  a robust architecture for distributed inference in sensor networks  in ipsn  5562,2005   16  j rao  s doraiswamy  et al  a deferred cleansing method for rfid data analytics  in vldb  175186  2006   17  smartcard focus  http  //www.smartcardfocus.com/shop/ ilp/se~72/p/index.shtml   18  j schiff  d antonelli  et al  robust message-passing for statistical inference in sensor networks  in ipsn  109118,2007   19  t tran  c sutton  r cocci  et al  probabilistic inference over rfid streams in mobile environments  in icde  2009   20  f wang and p liu  temporal management of rfid data  in vldb  11281139  2005   21  e welbourne  n khoussainova  et al  cascadia  a system for specifying  detecting  and managing rfid events  in mobisys  2008   22  e wu  y diao  and s rizvi  high-performance complex event processing over streams  in sigmod  407418  2006   23  j xie  j yang  y chen  et al  a sampling-based approach to information recovery  in icde  476485  2008  